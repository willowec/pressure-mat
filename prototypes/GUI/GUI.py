# GUI which displays data from the mat interpreted by the board and transmitted over serial
import sys, serial

import os
import os.path

from datetime import datetime

import PyQt6

from PyQt6.QtGui import  *
from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
#import PySide6
#from PyQt6.QtX11Extras import *


import numpy as np
import matplotlib
from matplotlib import pyplot as plt
matplotlib.use('QtAgg')

from PIL import Image

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg
from matplotlib.figure import Figure

MAT_DIM = (28, 56)
HIST_LEN = 25

"""
class MplCanvas(FigureCanvasQTAgg):
    
    https://www.pythonguis.com/tutorials/pyqt6-plotting-matplotlib/
    
    def __init__(self, parent=None, width=5, height=4, dpi=100):
        fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = fig.add_subplot(111)
        super(MplCanvas, self).__init__(fig)
"""


class MainWindow(QMainWindow):
    """
    Class which handles the main 
    """

    

    # initial class generated by chatgpt
    def __init__(self):
        super(MainWindow, self).__init__()
        self.setWindowTitle("28x56 Mat Interface")

        self.current_img_path = "default.png"
        self.current_img_index = -1

        self.layout = QGridLayout()
        
        #com port input box
        self.port_input = QLineEdit("COM8", self)
        self.layout.addWidget(QLabel("Port:", self), 1, 0)
        self.layout.addWidget(self.port_input, 2, 0)

        #baud rate input box
        self.baud_input = QLineEdit("115200", self)
        self.layout.addWidget(QLabel("Baud rate:", self), 1, 1)
        self.layout.addWidget(self.baud_input, 2, 1)

        #button to initialize serial connection to pi
        self.connect_b = QPushButton("Connect")
        self.connect_b.clicked.connect(self.connect_board)
        self.status_l = QLabel("Status: N/A")
        self.layout.addWidget(self.connect_b, 3, 0)
        self.layout.addWidget(self.status_l, 3, 1)

        #calibrate mat
        self.calibrate_b = QPushButton("Calibrate Mat")
        self.calibrate_b.clicked.connect(self.calibrate_mat)
        self.calibrate_status = QLabel("Status: Not Calibrated")
        self.layout.addWidget(self.calibrate_b, 4, 0)
        self.layout.addWidget(self.calibrate_status, 4, 1)

        #start/stop mat recording session
        self.start_session_b = QPushButton("Start Session")
        self.start_session_b.clicked.connect(self.start_session)
        self.stop_session_b = QPushButton("Stop Session")
        self.stop_session_b.clicked.connect(self.stop_session)
        self.session_status = QLabel("Status: Session Stopped")
        self.layout.addWidget(self.start_session_b, 5, 0)
        self.layout.addWidget(self.stop_session_b, 6, 0)
        self.layout.addWidget(self.session_status, 5, 1)
        
        #load past session
        self.load_past_img_b = QPushButton("Load Past Session")
        self.load_past_img_b.clicked.connect(self.load_past_img)
        self.layout.addWidget(self.load_past_img_b, 7, 0)


        #navigate past session buttons
        self.load_past_img_next_b = QPushButton("-->")
        self.load_past_img_prev_b = QPushButton("<--")
        self.load_past_img_next_b.clicked.connect(self.load_past_img_next)
        self.load_past_img_prev_b.clicked.connect(self.load_past_img_prev)
        self.layout.addWidget(self.load_past_img_next_b, 8, 1)
        self.layout.addWidget(self.load_past_img_prev_b, 8, 0)

   
        #display image from file
        self.size = QSize(56*10, 28*10)
        self.im = QPixmap("default.png")
        self.label = QLabel()
        self.qimage = QImage()
        self.im_scaled = self.im.scaled(self.size)
        self.qimage=self.im_scaled.toImage()
        self.label.setPixmap(self.im_scaled)
        self.layout.addWidget(self.label,0,2)


        widget = QWidget()
        widget.setLayout(self.layout)
        self.setCentralWidget(widget)
        self.show()

        # set up the default reciever thread
        self.reciever = Reciever("COM8", 115200, self)



    def connect_board(self):
        """
        Called by the connect button
        """
        
        # update the reciever thread with the input text box values
        self.reciever.baud = self.baud_input.text()
        self.reciever.port = self.port_input.text()

        # attempt to connect to the board
        self.reciever.connect_to_board()



        

    def calibrate_mat(self):
        print("I will calibrate the board")

    def start_session(self):
        print("I will start a mat recording session capped at 1 hour")
        new_session = session()
        new_session.run()

        self.reciever.start()

        return

    def stop_session(self):
        print("I will stop the mat recording session")
        new_session.stop()
 
    #opens file selector, saves a selected image, scales it, then displays it
    def load_past_img(self):
        
        fname = self.getfile()
        print("fname = ", fname)

        self.current_img_path = fname[(len(fname)-37):]
        #print("current_img_path = ", current_img_path)

        self.current_img_index = int(fname[(len(fname)-8):(len(fname)-4)])
        #print("current_img_index = ", current_img_index)

        self.label.setPixmap(QPixmap(fname).scaled(self.size))


    #input 1 for next file, -1 for previous file. Performs string manipulations to update the current image index and file path
    def get_next_file(self, prev_or_next):

        #check if valid arguement was passed to function
        if(prev_or_next == 1 or prev_or_next == -1):

            #check if trying to access a negative index file
            if(self.current_img_index == 0 and prev_or_next == -1):
                print("there is no image before image 0")
                return            

            next_file_index = self.current_img_index + prev_or_next
            next_file_name = str(next_file_index)

            #add zeros to next_index to make it the propper file name
            while(len(next_file_name) < 4):
                next_file_name = "0" + next_file_name

            #remove the previous image's file name, but keep its path, add the next/previous file name
            next_file_path = self.current_img_path[:(len(self.current_img_path)-8)] + next_file_name + ".png"

            #if the next file exists then open it
            if(os.path.isfile(next_file_path)):
                self.current_img_index = next_file_index
                self.current_img_path = next_file_path
                
            else:
                print("next file does not exist")
                return
        else:
            print("invalid arguement passed to get_next_img()")
            return
        

    #when image navigator is clicked, this updates the image to the file with the next index
    def load_past_img_next(self):
        self.get_next_file(1)
        self.label.setPixmap(QPixmap(self.current_img_path).scaled(self.size))

    #when image navigator is clicked, this updates the image to the file with the previous index
    def load_past_img_prev(self):
        self.get_next_file(-1)
        self.label.setPixmap(QPixmap(self.current_img_path).scaled(self.size))

    def closeEvent(self, event):
        """
        Called when the window is closed. Exit the application
        """
        self.reciever.terminate()

    #opens file selector, allows user to navigate their directories, and returns a string of the full file name
    def getfile(self):
        #default file path below
        file_path = ('./')

        fname_full = QFileDialog.getOpenFileName(self, 'Open file', file_path,"Image files (*.png)")
        return fname_full[0]
    
      
    
class session():

    def __init__(reciver: Reciever, self):
        self.isRunning = True

        #gets current date and time in the format of yy_mm_dd_THH_MM_SS
        #finds the current working directory then adds a folder named after the current time to /sessions
        now = datetime.now()
        folderName = now.strftime("%y_%m_%d_T%H_%M_%S")
        self.path = os.getcwd() + "\sessions\\" + folderName
        reciver.path = self.path
        os.mkdir(path)
        #print("folderName =", folderName)
        #print("path =", path)

        return


    def run(self):

        #while(self.isRunning):
        
        self.read_mat()
            #break

        return


    def stop(self):
        
        self.isRunning = False

        return

    def read_mat(self):
        return



class Reciever(QThread):
    """
    Thread which handles communcations to and from the board
    """
    def __init__(self, port: str, baud: int, parent):
        """
        Port is the com port to connect to and baud is its baud rate
        """
        super(Reciever, self).__init__()
        self.port = port
        self.baud = baud
        self.parent = parent
        self.run_sts = False
        self.path = os.getcwd()


    def connect_to_board(self):
        try:
            if(self.run_sts == False):
                # attempt to connect to the board
                with serial.Serial(self.port, baudrate=self.baud, timeout=10) as self.ser:
                    print(f"Connected to {self.ser.name}")
            else:
                print("Currently running, cannot connect to a new board. Please stop current session to connect to a new board.")
        except:
            print("Cannot connect to board. Please check entered port and baud rate.")


    def run(self):
        """
        Overrides the run() function. Called by reciever.start()
        """
        if(self.run_sts == False):
            self.run_sts = True
            # history stores the last HIST_LEN grid values
            self.history = np.zeros((HIST_LEN, 9))

            # poll incoming messages
            img_index = 0
            img_name = "0000"
            while True:
                m = self.ser.readline().decode('utf-8')
                print('recieved', m)
                if m == '':
                    self.run_sts = False
                    raise serial.SerialTimeoutException("Timed out")
                    

                # process the message
                vals = m.split('|')[:-1]
                imarray = np.asarray(vals, dtype=np.uint8).reshape(MAT_DIM)
                print('data\n', imarray)

                #add zeros to next_index and .png to make it the propper file name
                while(len(next_file_name) < 4):
                    img_name = "0" + img_name
                img_name += ".png"
                
                im = Image.fromarray(imarray, mode='L')
                im.save(img_name)  # Hack. ideally we should not have to save to file

                #increase image index
                img_index +=1
                img_name = str(img_index)

                
                """
                #Don't think this is necesessary right now 


                # update the pixmap
                self.parent.data_pixmap = QPixmap("sensor_data.png").scaled(10, 10)
                self.parent.data_display.setPixmap(self.parent.data_pixmap)
                self.parent.data_text.setText(str(imarray))

                # update the history array and render it
                self.history = np.roll(self.history, 1, axis=0)
                self.history[0, :] = imarray.flatten()
                #print(self.history)

                # plot it
                self.parent.hist_display.axes.cla()
                self.parent.hist_display.axes.set_ylim(bottom=0, top=256, auto=False)
                self.parent.hist_display.axes.plot(self.history)
                self.parent.hist_display.draw()

                """

        else:
            print("Currently running, cannot start a new session. Please stop current session to start a new one.")




if __name__ == "__main__":
    app = QApplication(sys.argv)

    window = MainWindow()

    # 4. Show your application's GUI
    window.show()

    # 5. Run your application's event loop
    sys.exit(app.exec())

